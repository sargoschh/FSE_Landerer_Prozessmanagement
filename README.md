# FSE_Landerer_Prozessmanagement

## AUFGABE 1: SCRUM-GRUNDLAGEN

1. **Ablauf**: SCRUM-Projekte laufen in Sprints ab, die in der Regel zwischen einer und vier Wochen dauern. Zu Beginn eines jeden Sprints wird ein Sprint-Planning-Meeting abgehalten, bei dem das Entwicklungsteam gemeinsam mit dem Product-Owner entscheidet, welche Aufgaben in diesem Sprint bearbeitet werden sollen. Die Aufgaben werden aus dem Product-Backlog, einer Liste aller geplanten Features und Änderungen, ausgewählt und im Sprint-Backlog festgehalten.
Während des Sprints hält das Entwicklungsteam jeden Tag ein Daily-Scrum-Meeting ab, in dem jeder Entwickler den Fortschritt seiner Arbeit beschreibt und potenzielle Hindernisse oder Probleme anspricht. Der Scrum-Master ist bei diesem Meeting anwesend, um sicherzustellen, dass der Prozess reibungslos läuft und um gegebenenfalls Probleme zu lösen.
Am Ende des Sprints findet ein Sprint-Review-Meeting statt, bei dem das Entwicklungsteam die Ergebnisse seines Sprints präsentiert und Feedback vom Product-Owner und anderen interessierten Stakeholdern erhält. Das Sprint-Review-Meeting bietet auch die Möglichkeit, die Ziele und Prioritäten für den nächsten Sprint zu besprechen und anzupassen.
Schließlich findet ein Sprint-Retrospektiv-Meeting statt, bei dem das Entwicklungsteam gemeinsam mit dem Scrum-Master und dem Product-Owner den vergangenen Sprint reflektiert und Verbesserungsmöglichkeiten diskutiert. Hierbei geht es darum, die Arbeitsprozesse und die Zusammenarbeit im Team zu evaluieren und zu optimieren.


2. **Ereignisse**:
Sprint Planning: Das Sprint-Planning-Meeting findet zu Beginn jedes Sprints statt und dient dazu, die Ziele und Aufgaben für den Sprint festzulegen. Hierbei wird das Entwicklungsteam vom Product-Owner unterstützt und berät sich, welche Aufgaben im Sprint umgesetzt werden können. Das Ergebnis ist das Sprint-Backlog, eine konkrete Planung für den Sprint.
Daily Scrum: Das Daily-Scrum-Meeting findet jeden Tag statt und dauert in der Regel nicht länger als 15 Minuten. Das Team tauscht sich hier aus, was am Vortag erreicht wurde und welche Aufgaben für den aktuellen Tag geplant sind. Ziel ist es, eine Übersicht über den Fortschritt des Projekts zu erhalten und mögliche Probleme rechtzeitig zu erkennen.
Sprint Review: Das Sprint-Review-Meeting findet am Ende eines jeden Sprints statt und dient dazu, die Ergebnisse des Sprints zu präsentieren und Feedback von allen Stakeholdern zu erhalten. Ziel ist es, sicherzustellen, dass das Projekt in die richtige Richtung läuft und Änderungen rechtzeitig zu erkennen.
Sprint Retrospective: Das Sprint-Retrospektive-Meeting findet ebenfalls am Ende eines Sprints statt und ermöglicht dem Team, die Arbeitsprozesse und Zusammenarbeit zu evaluieren und Verbesserungen für den nächsten Sprint zu diskutieren.
Backlog Refinement: Beim Backlog-Refinement werden neue Ideen und Anforderungen in das Product-Backlog eingearbeitet und vorhandene Aufgaben priorisiert und verfeinert. Ziel ist es, sicherzustellen, dass das Product-Backlog immer aktuell und aussagekräftig bleibt, um den Erfolg des Projekts sicherzustellen.

3. **Rollen**: In SCRUM-Projekten gibt es drei wichtige Rollen:
Scrum-Master: Der Scrum-Master ist verantwortlich für die Einhaltung der SCRUM-Praktiken und sorgt dafür, dass das Team effektiv und effizient arbeiten kann. Er unterstützt das Team bei der Umsetzung von SCRUM und löst Hindernisse, die den Projektfortschritt behindern.
Product-Owner: Der Product-Owner ist der Vertreter des Kunden und verantwortlich für die Erstellung und Priorisierung des Product-Backlogs. Er kommuniziert die Anforderungen und Wünsche des Kunden an das Entwicklungsteam und sorgt dafür, dass die Arbeit des Teams die Anforderungen des Kunden erfüllt.
Developer: Die Entwickler sind das Team, das die eigentliche Arbeit macht und das Produkt entwickelt. Sie sind verantwortlich für die Umsetzung der Aufgaben aus dem Sprint-Backlog und für die Qualität des Produkts.
4. **Artefakte**:
User Stories: User Stories sind kurze Beschreibungen von Anforderungen aus Sicht des Benutzers. Sie beschreiben, was der Benutzer erreichen möchte und welche Funktionen oder Eigenschaften das Produkt haben sollte, um seine Bedürfnisse zu erfüllen.
Product Backlog: Das Product-Backlog ist eine Liste von Anforderungen an das Produkt, die priorisiert und verfeinert werden. Es wird vom Product-Owner verwaltet und enthält alle Anforderungen, die das Team in Zukunft umsetzen soll.
Sprint Backlog: Das Sprint-Backlog ist eine Liste von Aufgaben, die das Team für den aktuellen Sprint aus dem Product-Backlog ausgewählt hat. Es enthält alle Aufgaben, die das Team in diesem Sprint erledigen muss, um das Ziel des Sprints zu erreichen.
Product Increment: Das Product-Increment ist die kumulative Summe aller fertigen Aufgaben und Funktionen, die in vorherigen Sprints abgeschlossen wurden. Es zeigt den Fortschritt des Produkts und wird bei jedem Sprint um neue Funktionen und Verbesserungen erweitert.
Burndown-Chart: Das Burndown-Chart ist eine visuelle Darstellung des Fortschritts des Sprints. Es zeigt, wie viel Arbeit noch zu erledigen ist und wie viel Zeit noch für den Sprint übrig ist. Es hilft dem Team, den Fortschritt zu verfolgen und rechtzeitig zu erkennen, ob das Team im Zeitplan liegt oder Verzögerungen aufgetreten sind.

## AUFGABE 2: SCRUM MIT GITLAB ODER GITHUB

1. Erstellung des Product-Backlogs: In GitLab oder GitHub kann man ein Repository erstellen, in dem das Product-Backlog gespeichert wird. Hierbei können User-Stories, Features, Bugs oder andere Anforderungen als Issues angelegt werden. Diese können dann vom Product-Owner priorisiert und von den Entwicklern bearbeitet werden.

2. Sprint-Planning: Das Sprint-Backlog kann in GitLab oder GitHub durch die Erstellung von Meilensteinen und Issues realisiert werden. Dabei werden die Issues aus dem Product-Backlog in den Meilenstein des aktuellen Sprints verschoben und entsprechend priorisiert.

3. Daily-Scrum: GitLab oder GitHub bieten die Möglichkeit, ein tägliches Stand-Up-Meeting virtuell abzuhalten. Hierbei können die Entwickler ihre Fortschritte im Kommentarbereich der entsprechenden Issues dokumentieren. Der Scrum-Master kann diese Kommentare lesen und mögliche Hindernisse frühzeitig erkennen.

4. Sprint-Review: In GitLab oder GitHub kann ein Sprint-Review durch die Erstellung von Merge-Requests realisiert werden. Diese ermöglichen es dem Team, die Ergebnisse des Sprints zu präsentieren und Feedback von allen Stakeholdern zu erhalten. Der Merge-Request enthält die vom Entwicklerteam fertiggestellten Änderungen oder neuen Funktionen, die dann von anderen Teammitgliedern geprüft und genehmigt werden können.

5. Sprint-Retrospektive: Die Retrospektive kann in GitLab oder GitHub durch die Erstellung von Issues realisiert werden, die die Zusammenarbeit und die Prozesse des Teams reflektieren. Das Team kann gemeinsam an diesen Issues arbeiten und Verbesserungen für den nächsten Sprint diskutieren.

6. Backlog-Refinement: GitLab oder GitHub können für das Backlog-Refinement durch die Erstellung von Labels und Epics eingesetzt werden. Labels ermöglichen es dem Team, Issues nach bestimmten Kriterien wie Priorität, Schwierigkeit oder Art zu gruppieren. Epics können genutzt werden, um größere Anforderungen oder Themenbereiche in kleinere Issues zu unterteilen.

Insgesamt bietet GitLab oder GitHub viele Funktionen, die SCRUM-Projektmanagement unterstützen können. Es ist jedoch wichtig, die verschiedenen Funktionen gezielt einzusetzen und auf die Bedürfnisse des eigenen Teams anzupassen. Eine konsistente Vorgehensweise könnte folgendermaßen aussehen:

1. Erstellung des Product-Backlogs als Issue-Liste im GitLab oder GitHub Repository.
2. Sprint-Planning durch Erstellung von Meilensteinen und Issues, die aus dem Product-Backlog ausgewählt und priorisiert wurden.
3. Durchführung des Daily-Scrums durch die Fortschrittsaktualisierung der Issues durch die Entwickler.
4. Sprint-Review durch die Vorstellung der fertigen Arbeit über Merge-Requests.
5. Sprint-Retrospektive durch die Diskussion von Issues, die speziell dafür erstellt wurden.
6. Backlog-Refinement durch Labels und Epics.

Diese Vorgehensweise kann je nach Projekt und Team angepasst werden, um ein effektives SCRUM-Projektmanagement in GitLab oder GitHub zu ermöglichen.

## AUFGABE 3: USER-STORIES

![INVEST-Kriterien](Bilder/invest-kriterien.jpg)

![UserCard_ProductOwner_01](Bilder/UserStory_ProductOwner_01.png)
- [x]   Independent: Die Story ist unabhängig von anderen Storys und kann alleine umgesetzt werden.
- [x]   Negotiable: Die genauen Anforderungen für das Benachrichtigungssystem können in der Zusammenarbeit zwischen dem Team und dem Product Owner verhandelt werden.
- [x]   Valuable: Die Funktion ist wertvoll für den Kino-Manager, um Probleme schnell zu erkennen und zu lösen.
- [x]   Estimable: Die Story ist gut schätzbar und es können klar definierte Kriterien für die Fertigstellung festgelegt werden.
- [x]   Small: Die Story ist klein genug, um innerhalb eines Sprints umgesetzt werden zu können.
- [x]   Testable: Die Funktionalität kann durch automatisierte Tests getestet werden.

![UserCard_ProductOwner_02](Bilder/UserStory_ProductOwner_02.png)
- [x]   Independent: Die Story ist unabhängig von anderen Storys und kann alleine umgesetzt werden.
- [x]   Negotiable: Die genauen Anforderungen für die Benutzerfreundlichkeit können in der Zusammenarbeit zwischen dem Team und dem Product Owner verhandelt werden.
- [x]   Valuable: Die Funktion ist wertvoll für den Kino-Manager, um effizienter arbeiten zu können.
- [ ]   Estimable: Die Story ist schwierig zu schätzen, da die Anforderungen für Benutzerfreundlichkeit subjektiv sind.
- [ ]   Small: Die Story könnte zu groß sein, um innerhalb eines Sprints umgesetzt zu werden.
- [x]   Testable: Die Funktionalität kann durch Benutzertests getestet werden.

![UserCard_ScrumMaster_01](Bilder/UserStory_ScrumMaster_01.png)
- [x]   Independent: Die Story ist unabhängig von anderen Storys und kann alleine umgesetzt werden.
- [x]   Negotiable: Die genauen Anforderungen für die Sitzplatzreservierungsfunktion können in der Zusammenarbeit zwischen dem Team und dem Product Owner verhandelt werden.
- [x]   Valuable: Die Funktion ist wertvoll für den Kino-Manager, um Sitzpläne effizient zu verwalten.
- [x]   Estimable: Die Story ist gut schätzbar und es können klar definierte Kriterien für die Fertigstellung festgelegt werden.
- [ ]   Small: Die Story könnte zu groß sein, um innerhalb eines Sprints umgesetzt zu werden.
- [x]   Testable: Die Funktionalität kann durch automatisierte Tests getestet werden.

![UserCard_ScrumMaster_02](Bilder/UserStory_ScrumMaster_02.png)
- [x]   Independent: Die Story ist unabhängig von anderen Storys und kann alleine umgesetzt werden.
- [x]   Negotiable: Die genauen Anforderungen für die benutzerfreundliche Oberfläche können in der Zusammenarbeit zwischen dem Team und dem Product Owner verhandelt werden.
- [x]   Valuable: Die Funktion ist wertvoll für den Kino-Manager, um schnell und einfach auf wichtige Kinoinformationen zugreifen zu können.
- [x]   Estimable: Die Story ist gut schätzbar und es können klar definierte Kriterien für die Fertigstellung festgelegt werden.
- [ ]   Small: Die Story könnte groß sein, je nach Umfang der relevanten Kinoinformationen. Es könnte hilfreich sein, sie in kleinere, besser schätzbare Teile zu zerlegen.
- [x]   Testable: Die Funktionalität kann durch Benutzertests getestet werden.

![UserCard_Developer_01](Bilder/UserStory_Developer_01.png)
- [x]   Independent: Die Story ist unabhängig von anderen Storys und kann alleine umgesetzt werden.
- [x]   Negotiable: Die genauen Anforderungen für die Funktionen zum Hinzufügen, Bearbeiten und Löschen von Filmen und Spielzeiten können in der Zusammenarbeit zwischen dem Team und dem Product Owner verhandelt werden.
- [x]   Valuable: Die Funktion ist wertvoll für den Kino-Manager, um die Film- und Spielzeitplanung flexibel zu verwalten.
- [x]   Estimable: Die Story ist gut schätzbar und es können klar definierte Kriterien für die Fertigstellung festgelegt werden.
- [x]   Small: Die Story ist in der Regel klein genug, um innerhalb eines Sprints umgesetzt zu werden.
- [x]   Testable: Die Funktionalität kann durch automatisierte Tests getestet werden.

![UserCard_Developer_02](Bilder/UserStory_Developer_02.png)
- [x]   Independent: Die Story ist unabhängig von anderen Storys und kann alleine umgesetzt werden.
- [x]   Negotiable: Die genauen Anforderungen für die Feedback-Funktion können in der Zusammenarbeit zwischen dem Team und dem Product Owner verhandelt werden.
- [x]   Valuable: Die Funktion ist wertvoll, um das Feedback der Kinobesucher zu erhalten und die App kontinuierlich zu verbessern.
- [x]   Estimable: Die Story ist gut schätzbar und es können klar definierte Kriterien für die Fertigstellung festgelegt werden.
- [x]   Small: Die Story ist in der Regel klein genug, um innerhalb eines Sprints umgesetzt zu werden.
- [x]   Testable: Die Funktionalität kann durch automatisierte Tests getestet werden.

## AUFGABE 4: ABWICKLUNG MIT GITLAB ODER GITHUB

![GIT_Repo](Bilder/GIT_Repo.jpg)

![Issue_01](Bilder/Issue_01.jpg)

![Issue_02](Bilder/Issue_02.jpg)

## AUFGABE 5: AGILES PM, VERSIONSKONTROLLE UND CI

Die Kombination von leichtgewichtigen Versionskontrollmechanismen wie Trunk-based Development oder GitHub Flow mit Continuous Integration (CI) und automatisiertem Testen kann einen effizienten Entwicklungsprozess unterstützen, wenn sie in Verbindung mit Scrum eingesetzt werden. Hier sind einige Überlegungen dazu:

- Integration von CI in den Sprint: Innerhalb eines Sprints kann die CI-Praxis in den Entwicklungsprozess integriert werden. Entwickler können ihre Änderungen regelmäßig in den Hauptentwicklungszweig (Trunk) oder den Hauptbranch (bei GitHub Flow) zusammenführen. Dabei wird automatisch ein CI-Prozess ausgelöst, der den Code kompiliert, Tests ausführt und Qualitätsmetriken überprüft. Dadurch werden frühzeitig Fehler erkannt und die Teammitglieder können schnell Feedback erhalten.

- Automatisierte Tests: Durch die Kombination von CI mit automatisierten Tests können Teams sicherstellen, dass die Anwendung bei jeder Code-Integration ordnungsgemäß funktioniert. Dies umfasst Unit-Tests, Integrationstests und ggf. UI-Tests. Die automatisierten Tests sollten in den CI-Prozess integriert werden, sodass sie bei jeder Code-Integration automatisch ausgeführt werden. Dies ermöglicht eine schnelle Rückmeldung über die Qualität des Codes und hilft, potenzielle Fehler frühzeitig zu erkennen.

- Code-Reviews und Pull Requests: Bei GitHub Flow können Entwickler Änderungen über Pull Requests einreichen, bevor sie in den Hauptbranch gemerged werden. Dies ermöglicht es dem Team, den Code zu überprüfen und Feedback zu geben. Code-Reviews sollten in den Scrum-Prozess integriert werden, beispielsweise als Teil des Definition of Done (DoD) für User Stories. Durch regelmäßige Code-Reviews kann die Codequalität verbessert und das Wissen im Team geteilt werden.

- Automatisierte Codeanalyse: Die Verwendung von Tools zur automatisierten Codeanalyse wie statischen Code-Analysewerkzeugen oder Linters kann dazu beitragen, Code-Qualitätsstandards durchzusetzen und potenzielle Probleme zu identifizieren. Diese Tools können in den CI-Prozess integriert werden, um den Code kontinuierlich auf Code-Stil, Sicherheitslücken und andere Best Practices zu überprüfen.

- Einsatz von Feature-Flags: Feature-Flags ermöglichen es, neue Funktionen zu entwickeln und sie separat vom Hauptcodezweig zu aktivieren oder zu deaktivieren. Dadurch können Änderungen stufenweise ausgerollt und mögliche Auswirkungen auf die Anwendung überwacht werden. Feature-Flags können mit der Versionskontrolle und CI-Systemen integriert werden, um eine granulare Kontrolle über den Bereitstellungsprozess zu ermöglichen.

## AUFGABE 6: AGILES PM, VERSIONSKONTROLLE IN DER PRAXIS

Nun wird ein Workflow durchgespielt. Der ScrumMaster und der ProductOwner nehmen dazu die Rolle des Entwicklers ein.

Die Issues wurden erstellt und in den Sprint Backlog eingefügt:
![Git_Issues_01](Bilder/Git_Issues_01.jpg)

Ein neuer Workflow wird erstellt - dazu wird die Vorlage "Java with Maven" verwendet:
![Git_Workflow_01](Bilder/Git_Workflow_01.jpg)

Die Datei "maven_sarah.yml" wird überarbeitet:
![Git_Workflow_02](Bilder/Git_Workflow_02.jpg)

````yaml
# This workflow will build a Java project with Maven, and cache/restore any dependencies to improve the workflow execution time
# For more information see: https://docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-java-with-maven

# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.

name: Java CI with Maven

on:
  push:
    branches: [ "dev_sarah" ]
  pull_request:
    branches: [ "dev" ]
        # beim Push auf "dev_sarah" oder bei einem Pull Request auf "dev" wird der Workflow ausgeführt.
jobs:
  build:

    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v3
    - name: Set up JDK 17
      uses: actions/setup-java@v3
      with:
        java-version: '17'
        distribution: 'temurin'
        cache: maven
    - name: Build with Maven
      run: mvn -B package --file tdd-kino/pom.xml
    - name: Run Tests
      run: |
        cd tdd-kino
        mvn test
    # hier wird spezifiziert, dass die Tests im Programm ausgeführt werden
    
````

Beim Erstellen des Workflows wird gleichzeitig ein neuer Branch erstellt:

![Git_Workflow_03](Bilder/Git_Workflow_03.jpg)

Die neuen Änderungen werden mit einem PullRequest auf den Dev-Branch gemerged:

![Git_Workflow_04](Bilder/Git_Workflow_04.jpg)

Alle Überprüfungen haben funktioniert:

![Git_Workflow_05](Bilder/Git_Workflow_05.jpg)

Der Merge wurde durchgeführt:

![Git_Workflow_06](Bilder/Git_Workflow_06.jpg)

Hier sind nun alle erstellten Branches ersichtlich:

![Git_Workflow_07](Bilder/Git_Workflow_07.jpg)

Die Bearbeitung des Projekts beginnt - somit wurden die Issues nach "In Progress" verschoben:

![Git_Issues_02](Bilder/Git_Issues_02.jpg)

Lokal wird das Repository gepullt und der Branch gewechselt:

![Git_Workflow_08](Bilder/Git_Workflow_08.jpg)

In IntelliJ sind die bisherigen Commits ersichtlich - der aktuelle Branch ist "dev_sarah":

![Git_Workflow_09](Bilder/Git_Workflow_09.jpg)

Im Code wurde ein Kommentar hinzugefügt:

![Git_Workflow_10](Bilder/Git_Workflow_10.jpg)

Die Änderungen werden commited und gepusht:

![Git_Workflow_11](Bilder/Git_Workflow_11.jpg)

Im Remote-Repository sieht man, dass die Test automatisch abgelaufen sind:

![Git_Workflow_12](Bilder/Git_Workflow_12.jpg)

Die "Aufgabe" des Issues wurde erfüllt und kann nun kontrolliert & gemerged werden:

![Git_Issues_03](Bilder/Git_Issues_03.jpg)

Ein neuer PullRequest wird erstellt - von "dev_sarah" auf "dev":

![Git_Workflow_13](Bilder/Git_Workflow_13.jpg)

Die Änderungen im Code sind ersichtlich und erzeugen keinen Konflikt:

![Git_Workflow_14](Bilder/Git_Workflow_14.jpg)

Der PullRequest kann abgesetzt werden:

![Git_Workflow_15](Bilder/Git_Workflow_15.jpg)

Nachdem alle Tests und Checks erfolgreich waren, kann der PullRequest gemerged werden:

![Git_Workflow_16](Bilder/Git_Workflow_16.jpg)

Anschließend kann der Branch "dev_sarah" gelöscht werden:

![Git_Workflow_17](Bilder/Git_Workflow_17.jpg)

Nachdem alle Work-Branches in den "dev"-Branch gemerged wurden, wird nun auch der "dev"-Branch in den "main"-Branch gemerged:

![Git_Workflow_18](Bilder/Git_Workflow_18.jpg)

Das Mergen erzeugt keine Konflikte:

![Git_Workflow_19](Bilder/Git_Workflow_19.jpg)

Der PullRequest wurde erfolgreich gemerged und der "dev"-Branch kann gelöscht werden:

![Git_Workflow_20](Bilder/Git_Workflow_20.jpg)

Nun ist nur mehr der "main"-Branch verfügbar:

![Git_Workflow_21](Bilder/Git_Workflow_21.jpg)

Die Issues können als "abgeschlossen" markiert werden:

![Git_Issues_04](Bilder/Git_Issues_04.jpg)