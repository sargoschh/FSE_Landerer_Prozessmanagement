# FSE_Landerer_Prozessmanagement

## AUFGABE 1: SCRUM-GRUNDLAGEN

1. **Ablauf**: SCRUM-Projekte laufen in Sprints ab, die in der Regel zwischen einer und vier Wochen dauern. Zu Beginn eines jeden Sprints wird ein Sprint-Planning-Meeting abgehalten, bei dem das Entwicklungsteam gemeinsam mit dem Product-Owner entscheidet, welche Aufgaben in diesem Sprint bearbeitet werden sollen. Die Aufgaben werden aus dem Product-Backlog, einer Liste aller geplanten Features und Änderungen, ausgewählt und im Sprint-Backlog festgehalten.
Während des Sprints hält das Entwicklungsteam jeden Tag ein Daily-Scrum-Meeting ab, in dem jeder Entwickler den Fortschritt seiner Arbeit beschreibt und potenzielle Hindernisse oder Probleme anspricht. Der Scrum-Master ist bei diesem Meeting anwesend, um sicherzustellen, dass der Prozess reibungslos läuft und um gegebenenfalls Probleme zu lösen.
Am Ende des Sprints findet ein Sprint-Review-Meeting statt, bei dem das Entwicklungsteam die Ergebnisse seines Sprints präsentiert und Feedback vom Product-Owner und anderen interessierten Stakeholdern erhält. Das Sprint-Review-Meeting bietet auch die Möglichkeit, die Ziele und Prioritäten für den nächsten Sprint zu besprechen und anzupassen.
Schließlich findet ein Sprint-Retrospektiv-Meeting statt, bei dem das Entwicklungsteam gemeinsam mit dem Scrum-Master und dem Product-Owner den vergangenen Sprint reflektiert und Verbesserungsmöglichkeiten diskutiert. Hierbei geht es darum, die Arbeitsprozesse und die Zusammenarbeit im Team zu evaluieren und zu optimieren.


2. **Ereignisse**:
Sprint Planning: Das Sprint-Planning-Meeting findet zu Beginn jedes Sprints statt und dient dazu, die Ziele und Aufgaben für den Sprint festzulegen. Hierbei wird das Entwicklungsteam vom Product-Owner unterstützt und berät sich, welche Aufgaben im Sprint umgesetzt werden können. Das Ergebnis ist das Sprint-Backlog, eine konkrete Planung für den Sprint.
Daily Scrum: Das Daily-Scrum-Meeting findet jeden Tag statt und dauert in der Regel nicht länger als 15 Minuten. Das Team tauscht sich hier aus, was am Vortag erreicht wurde und welche Aufgaben für den aktuellen Tag geplant sind. Ziel ist es, eine Übersicht über den Fortschritt des Projekts zu erhalten und mögliche Probleme rechtzeitig zu erkennen.
Sprint Review: Das Sprint-Review-Meeting findet am Ende eines jeden Sprints statt und dient dazu, die Ergebnisse des Sprints zu präsentieren und Feedback von allen Stakeholdern zu erhalten. Ziel ist es, sicherzustellen, dass das Projekt in die richtige Richtung läuft und Änderungen rechtzeitig zu erkennen.
Sprint Retrospective: Das Sprint-Retrospektive-Meeting findet ebenfalls am Ende eines Sprints statt und ermöglicht dem Team, die Arbeitsprozesse und Zusammenarbeit zu evaluieren und Verbesserungen für den nächsten Sprint zu diskutieren.
Backlog Refinement: Beim Backlog-Refinement werden neue Ideen und Anforderungen in das Product-Backlog eingearbeitet und vorhandene Aufgaben priorisiert und verfeinert. Ziel ist es, sicherzustellen, dass das Product-Backlog immer aktuell und aussagekräftig bleibt, um den Erfolg des Projekts sicherzustellen.

3. **Rollen**: In SCRUM-Projekten gibt es drei wichtige Rollen:
Scrum-Master: Der Scrum-Master ist verantwortlich für die Einhaltung der SCRUM-Praktiken und sorgt dafür, dass das Team effektiv und effizient arbeiten kann. Er unterstützt das Team bei der Umsetzung von SCRUM und löst Hindernisse, die den Projektfortschritt behindern.
Product-Owner: Der Product-Owner ist der Vertreter des Kunden und verantwortlich für die Erstellung und Priorisierung des Product-Backlogs. Er kommuniziert die Anforderungen und Wünsche des Kunden an das Entwicklungsteam und sorgt dafür, dass die Arbeit des Teams die Anforderungen des Kunden erfüllt.
Developer: Die Entwickler sind das Team, das die eigentliche Arbeit macht und das Produkt entwickelt. Sie sind verantwortlich für die Umsetzung der Aufgaben aus dem Sprint-Backlog und für die Qualität des Produkts.
4. **Artefakte**:
User Stories: User Stories sind kurze Beschreibungen von Anforderungen aus Sicht des Benutzers. Sie beschreiben, was der Benutzer erreichen möchte und welche Funktionen oder Eigenschaften das Produkt haben sollte, um seine Bedürfnisse zu erfüllen.
Product Backlog: Das Product-Backlog ist eine Liste von Anforderungen an das Produkt, die priorisiert und verfeinert werden. Es wird vom Product-Owner verwaltet und enthält alle Anforderungen, die das Team in Zukunft umsetzen soll.
Sprint Backlog: Das Sprint-Backlog ist eine Liste von Aufgaben, die das Team für den aktuellen Sprint aus dem Product-Backlog ausgewählt hat. Es enthält alle Aufgaben, die das Team in diesem Sprint erledigen muss, um das Ziel des Sprints zu erreichen.
Product Increment: Das Product-Increment ist die kumulative Summe aller fertigen Aufgaben und Funktionen, die in vorherigen Sprints abgeschlossen wurden. Es zeigt den Fortschritt des Produkts und wird bei jedem Sprint um neue Funktionen und Verbesserungen erweitert.
Burndown-Chart: Das Burndown-Chart ist eine visuelle Darstellung des Fortschritts des Sprints. Es zeigt, wie viel Arbeit noch zu erledigen ist und wie viel Zeit noch für den Sprint übrig ist. Es hilft dem Team, den Fortschritt zu verfolgen und rechtzeitig zu erkennen, ob das Team im Zeitplan liegt oder Verzögerungen aufgetreten sind.

## AUFGABE 2: SCRUM MIT GITLAB ODER GITHUB

1. Erstellung des Product-Backlogs: In GitLab oder GitHub kann man ein Repository erstellen, in dem das Product-Backlog gespeichert wird. Hierbei können User-Stories, Features, Bugs oder andere Anforderungen als Issues angelegt werden. Diese können dann vom Product-Owner priorisiert und von den Entwicklern bearbeitet werden.

2. Sprint-Planning: Das Sprint-Backlog kann in GitLab oder GitHub durch die Erstellung von Meilensteinen und Issues realisiert werden. Dabei werden die Issues aus dem Product-Backlog in den Meilenstein des aktuellen Sprints verschoben und entsprechend priorisiert.

3. Daily-Scrum: GitLab oder GitHub bieten die Möglichkeit, ein tägliches Stand-Up-Meeting virtuell abzuhalten. Hierbei können die Entwickler ihre Fortschritte im Kommentarbereich der entsprechenden Issues dokumentieren. Der Scrum-Master kann diese Kommentare lesen und mögliche Hindernisse frühzeitig erkennen.

4. Sprint-Review: In GitLab oder GitHub kann ein Sprint-Review durch die Erstellung von Merge-Requests realisiert werden. Diese ermöglichen es dem Team, die Ergebnisse des Sprints zu präsentieren und Feedback von allen Stakeholdern zu erhalten. Der Merge-Request enthält die vom Entwicklerteam fertiggestellten Änderungen oder neuen Funktionen, die dann von anderen Teammitgliedern geprüft und genehmigt werden können.

5. Sprint-Retrospektive: Die Retrospektive kann in GitLab oder GitHub durch die Erstellung von Issues realisiert werden, die die Zusammenarbeit und die Prozesse des Teams reflektieren. Das Team kann gemeinsam an diesen Issues arbeiten und Verbesserungen für den nächsten Sprint diskutieren.

6. Backlog-Refinement: GitLab oder GitHub können für das Backlog-Refinement durch die Erstellung von Labels und Epics eingesetzt werden. Labels ermöglichen es dem Team, Issues nach bestimmten Kriterien wie Priorität, Schwierigkeit oder Art zu gruppieren. Epics können genutzt werden, um größere Anforderungen oder Themenbereiche in kleinere Issues zu unterteilen.

Insgesamt bietet GitLab oder GitHub viele Funktionen, die SCRUM-Projektmanagement unterstützen können. Es ist jedoch wichtig, die verschiedenen Funktionen gezielt einzusetzen und auf die Bedürfnisse des eigenen Teams anzupassen. Eine konsistente Vorgehensweise könnte folgendermaßen aussehen:

1. Erstellung des Product-Backlogs als Issue-Liste im GitLab oder GitHub Repository.
2. Sprint-Planning durch Erstellung von Meilensteinen und Issues, die aus dem Product-Backlog ausgewählt und priorisiert wurden.
3. Durchführung des Daily-Scrums durch die Fortschrittsaktualisierung der Issues durch die Entwickler.
4. Sprint-Review durch die Vorstellung der fertigen Arbeit über Merge-Requests.
5. Sprint-Retrospektive durch die Diskussion von Issues, die speziell dafür erstellt wurden.
6. Backlog-Refinement durch Labels und Epics.

Diese Vorgehensweise kann je nach Projekt und Team angepasst werden, um ein effektives SCRUM-Projektmanagement in GitLab oder GitHub zu ermöglichen.

## AUFGABE 3: USER-STORIES

![INVEST-Kriterien](Bilder/invest-kriterien.jpg)

![UserCard_ProductOwner_01](Bilder/UserStory_ProductOwner_01.png)
- [x]   Independent / Unabhängig: User Stories sollten unabhängig voneinander sein
- [x]   Negotiable / Verhandelbar: User Stories sollten verhandelbar sein
- [x]   Valuable / Wertvoll: User Stories sollten einen Wert für den Kunden besitzen
- [x]   Estimatable / Schätzbar: User Stories sollten schätzbar sein
- [x]   Small / Klein: User Stories sollten klein sein
- [x]   Testable / Testbar: User Stories sollten testbar sein

![UserCard_ProductOwner_02](Bilder/UserStory_ProductOwner_02.png)
- [x]   Independent / Unabhängig: User Stories sollten unabhängig voneinander sein
- [x]   Negotiable / Verhandelbar: User Stories sollten verhandelbar sein
- [x]   Valuable / Wertvoll: User Stories sollten einen Wert für den Kunden besitzen
- [x]   Estimatable / Schätzbar: User Stories sollten schätzbar sein
- [x]   Small / Klein: User Stories sollten klein sein
- [x]   Testable / Testbar: User Stories sollten testbar sein

![UserCard_ScrumMaster_01](Bilder/UserStory_ScrumMaster_01.png)
- [x]   Independent / Unabhängig: User Stories sollten unabhängig voneinander sein
- [x]   Negotiable / Verhandelbar: User Stories sollten verhandelbar sein
- [x]   Valuable / Wertvoll: User Stories sollten einen Wert für den Kunden besitzen
- [x]   Estimatable / Schätzbar: User Stories sollten schätzbar sein
- [x]   Small / Klein: User Stories sollten klein sein
- [x]   Testable / Testbar: User Stories sollten testbar sein

![UserCard_ScrumMaster_02](Bilder/UserStory_ScrumMaster_02.png)
- [x]   Independent / Unabhängig: User Stories sollten unabhängig voneinander sein
- [x]   Negotiable / Verhandelbar: User Stories sollten verhandelbar sein
- [x]   Valuable / Wertvoll: User Stories sollten einen Wert für den Kunden besitzen
- [x]   Estimatable / Schätzbar: User Stories sollten schätzbar sein
- [x]   Small / Klein: User Stories sollten klein sein
- [x]   Testable / Testbar: User Stories sollten testbar sein

![UserCard_Developer_01](Bilder/UserStory_Developer_01.png)
- [x]   Independent / Unabhängig: User Stories sollten unabhängig voneinander sein
- [x]   Negotiable / Verhandelbar: User Stories sollten verhandelbar sein
- [x]   Valuable / Wertvoll: User Stories sollten einen Wert für den Kunden besitzen
- [x]   Estimatable / Schätzbar: User Stories sollten schätzbar sein
- [x]   Small / Klein: User Stories sollten klein sein
- [x]   Testable / Testbar: User Stories sollten testbar sein

![UserCard_Developer_02](Bilder/UserStory_Developer_02.png)
- [x]   Independent / Unabhängig: User Stories sollten unabhängig voneinander sein
- [x]   Negotiable / Verhandelbar: User Stories sollten verhandelbar sein
- [x]   Valuable / Wertvoll: User Stories sollten einen Wert für den Kunden besitzen
- [x]   Estimatable / Schätzbar: User Stories sollten schätzbar sein
- [x]   Small / Klein: User Stories sollten klein sein
- [x]   Testable / Testbar: User Stories sollten testbar sein

## AUFGABE 4: ABWICKLUNG MIT GITLAB ODER GITHUB

![GIT_Repo](Bilder/GIT_Repo.jpg)

![Issue_01](Bilder/Issue_01.jpg)

![Issue_02](Bilder/Issue_02.jpg)

## AUFGABE 5: AGILES PM, VERSIONSKONTROLLE UND CI

Die Kombination von leichtgewichtigen Versionskontrollmechanismen wie Trunk-based Development oder GitHub Flow mit Continuous Integration (CI) und automatisiertem Testen kann einen effizienten Entwicklungsprozess unterstützen, wenn sie in Verbindung mit Scrum eingesetzt werden. Hier sind einige Überlegungen dazu:

- Integration von CI in den Sprint: Innerhalb eines Sprints kann die CI-Praxis in den Entwicklungsprozess integriert werden. Entwickler können ihre Änderungen regelmäßig in den Hauptentwicklungszweig (Trunk) oder den Hauptbranch (bei GitHub Flow) zusammenführen. Dabei wird automatisch ein CI-Prozess ausgelöst, der den Code kompiliert, Tests ausführt und Qualitätsmetriken überprüft. Dadurch werden frühzeitig Fehler erkannt und die Teammitglieder können schnell Feedback erhalten.

- Automatisierte Tests: Durch die Kombination von CI mit automatisierten Tests können Teams sicherstellen, dass die Anwendung bei jeder Code-Integration ordnungsgemäß funktioniert. Dies umfasst Unit-Tests, Integrationstests und ggf. UI-Tests. Die automatisierten Tests sollten in den CI-Prozess integriert werden, sodass sie bei jeder Code-Integration automatisch ausgeführt werden. Dies ermöglicht eine schnelle Rückmeldung über die Qualität des Codes und hilft, potenzielle Fehler frühzeitig zu erkennen.

- Code-Reviews und Pull Requests: Bei GitHub Flow können Entwickler Änderungen über Pull Requests einreichen, bevor sie in den Hauptbranch gemerged werden. Dies ermöglicht es dem Team, den Code zu überprüfen und Feedback zu geben. Code-Reviews sollten in den Scrum-Prozess integriert werden, beispielsweise als Teil des Definition of Done (DoD) für User Stories. Durch regelmäßige Code-Reviews kann die Codequalität verbessert und das Wissen im Team geteilt werden.

- Automatisierte Codeanalyse: Die Verwendung von Tools zur automatisierten Codeanalyse wie statischen Code-Analysewerkzeugen oder Linters kann dazu beitragen, Code-Qualitätsstandards durchzusetzen und potenzielle Probleme zu identifizieren. Diese Tools können in den CI-Prozess integriert werden, um den Code kontinuierlich auf Code-Stil, Sicherheitslücken und andere Best Practices zu überprüfen.

Einsatz von Feature-Flags: Feature-Flags ermöglichen es, neue Funktionen zu entwickeln und sie separat vom Hauptcodezweig zu aktivieren oder zu deaktivieren. Dadurch können Änderungen stufenweise ausgerollt und mögliche Auswirkungen auf die Anwendung überwacht werden. Feature-Flags können mit der Versionskontrolle und CI-Systemen integriert werden, um eine granulare Kontrolle über den Bereitstellungsprozess zu ermöglichen.

## AUFGABE 6: AGILES PM, VERSIONSKONTROLLE IN DER PRAXIS